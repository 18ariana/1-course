import pandas as pd
import numpy as np


def cost_function(X, Y, theta):
    return (Y - X * theta).T * (Y - X * theta) # целевая функция


class GDRegression:
    def __init__(self, alpha=0.00001, n_iter=100):
        self.alpha = alpha
        self.iter = n_iter

    def fit(self, X, y):# x - матрица признаков, у - вектор ответов
        self.theta = np.matrix(X, dtype='float64') * 0
        y = np.matrix(y, dtype='float64')
        self.theta_history = [0] * self.iter # iter - число итераций
        self.cost_history = [0] * self.iter # делаем массивы размеров с количество итераций, чтобы потом их заполнять данными по тете и целевой функции и хранить старые значения
        t = X.transpose() #транспонируем матрицу для формулы
        m = y.size
        for i in range(1, self.iter):
            self.theta -= self.alpha * (t.dot(self.theta * X - y.reshape((m, 1)))) / m # .dot - перемножение матриц, считаем тету
            self.theta_history[i] = self.theta #записываем значение в массив старых значений
            self.cost_history[i] = sum(self.theta - y.reshape((m, 1))) ** 2 / (2 * m) # записываем значение целевой функции
        coef_ = self.theta[0] #self.theta[0] - вектор значений
        intercept_ = self.theta[1] #[1] - вектор оценок
        return coef_, intercept_

    def predict(self, X):
        previous_cost = 10
        Y = np.matrix(df['VIQ'])
        m = Y.size
        current_cost = sum(self.theta - Y.reshape((40, 1))) ** 2 / (2 * m)
        X = df['FSIQ']
        ESP = 0.1  # корень суммы квадрата значений градиента
        derivatives = [0] * len(self.theta)  # для подсчёта производных
        while np.abs(previous_cost - current_cost) > ESP:
            previous_cost = current_cost
            i = np.random.randint(0, len(Y))
            for j in range(len(self.theta)):
                derivatives[j] = (Y[i] - X[i] * self.theta[i]) * X[i]
            current_cost = sum(self.theta - Y.reshape((40, 1))) ** 2 / (2 * m)
            break

        self.theta[0] += self.alpha * derivatives[0][0,0]
        self.theta[1] += self.alpha * derivatives[0][0,1]

        coef_ = self.theta[0]
        intercept_ = self.theta[1]
        return coef_, intercept_


if __name__ == '__main__':
    df = pd.read_csv('brain_size.csv')
    X = df.iloc[:, 1:2]
    # X = df['FSIQ']
    Y = df['VIQ']
    model = GDRegression()
    print(model.fit(X, Y))
    print(model.predict(X))
